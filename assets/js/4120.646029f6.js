"use strict";(self.webpackChunk_graphql_codegen_website=self.webpackChunk_graphql_codegen_website||[]).push([[4120],{92406:function(e,t,n){n.d(t,{y:function(){return a}});var r=n(59329),o=n(7990);function a(e,t,n){var a;const i=e instanceof Error?e:new Error("Unexpected error value: "+(0,r.X)(e));return u=i,Array.isArray(u.path)?i:new o.__(i.message,null!==(a=i.nodes)&&void 0!==a?a:t,i.source,i.positions,n,i);var u}},64120:function(e,t,n){n.d(t,{td:function(){return $},VZ:function(){return O},p$:function(){return E},El:function(){return M},mn:function(){return I},ht:function(){return _},p0:function(){return g},Vm:function(){return F}});var r=n(59329);var o=n(87021),a=n(34317),i=n(82182),u=n(52689);var s=n(88274),l=n(98130),c=n(7990),f=n(92406),p=n(35239),d=n(57554),h=n(96374),m=n(82299),v=n(1346),y=n(93059),w=n(36819);const b=function(e){let t;return function(n,r,o){void 0===t&&(t=new WeakMap);let a=t.get(n);void 0===a&&(a=new WeakMap,t.set(n,a));let i=a.get(r);void 0===i&&(i=new WeakMap,a.set(r,i));let u=i.get(o);return void 0===u&&(u=e(n,r,o),i.set(o,u)),u}}(((e,t,n)=>(0,w.w)(e.schema,e.fragments,e.variableValues,t,n)));function _(e){const{schema:t,document:n,variableValues:r,rootValue:o}=e;$(t,n,r);const a=O(e);if(!("schema"in a))return{errors:a};try{const{operation:e}=a,t=function(e,t,n){const r=e.schema.getRootType(t.operation);if(null==r)throw new c.__(`Schema is not configured to execute ${t.operation} operation.`,t);const o=(0,w.g)(e.schema,e.fragments,e.variableValues,r,t.selectionSet),a=void 0;switch(t.operation){case p.ku.QUERY:return N(e,r,n,a,o);case p.ku.MUTATION:return function(e,t,n,r,o){return function(e,t,n){let r=n;for(const o of e)r=(0,i.t)(r)?r.then((e=>t(e,o))):t(r,o);return r}(o.entries(),((o,[a,u])=>{const l=(0,s.Q)(r,a,t.name),c=V(e,t,n,u,l);return void 0===c?o:(0,i.t)(c)?c.then((e=>(o[a]=e,o))):(o[a]=c,o)}),Object.create(null))}(e,r,n,a,o);case p.ku.SUBSCRIPTION:return N(e,r,n,a,o)}}(a,e,o);return(0,i.t)(t)?t.then((e=>T(e,a.errors)),(e=>(a.errors.push(e),T(null,a.errors)))):T(t,a.errors)}catch(u){return a.errors.push(u),T(null,a.errors)}}function g(e){const t=_(e);if((0,i.t)(t))throw new Error("GraphQL execution failed to complete synchronously.");return t}function T(e,t){return 0===t.length?{data:e}:{errors:t,data:e}}function $(e,t,n){t||(0,a.a)(!1,"Must provide document."),(0,h.J)(e),null==n||(0,u.y)(n)||(0,a.a)(!1,"Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.")}function O(e){var t,n;const{schema:r,document:o,rootValue:a,contextValue:i,variableValues:u,operationName:s,fieldResolver:l,typeResolver:f,subscribeFieldResolver:p}=e;let h;const m=Object.create(null);for(const y of o.definitions)switch(y.kind){case d.h.OPERATION_DEFINITION:if(null==s){if(void 0!==h)return[new c.__("Must provide operation name if query contains multiple operations.")];h=y}else(null===(t=y.name)||void 0===t?void 0:t.value)===s&&(h=y);break;case d.h.FRAGMENT_DEFINITION:m[y.name.value]=y}if(!h)return null!=s?[new c.__(`Unknown operation named "${s}".`)]:[new c.__("Must provide an operation.")];const v=null!==(n=h.variableDefinitions)&&void 0!==n?n:[],w=(0,y.QF)(r,v,null!=u?u:{},{maxErrors:50});return w.errors?w.errors:{schema:r,fragments:m,rootValue:a,contextValue:i,operation:h,variableValues:w.coerced,fieldResolver:null!=l?l:M,typeResolver:null!=f?f:I,subscribeFieldResolver:null!=p?p:M,errors:[]}}function N(e,t,n,r,o){const a=Object.create(null);let u=!1;for(const[c,f]of o.entries()){const o=V(e,t,n,f,(0,s.Q)(r,c,t.name));void 0!==o&&(a[c]=o,(0,i.t)(o)&&(u=!0))}return u?(l=a,Promise.all(Object.values(l)).then((e=>{const t=Object.create(null);for(const[n,r]of Object.keys(l).entries())t[r]=e[n];return t}))):a;var l}function V(e,t,n,r,o){var a;const u=F(e.schema,t,r[0]);if(!u)return;const l=u.type,c=null!==(a=u.resolve)&&void 0!==a?a:e.fieldResolver,p=E(e,u,r,t,o);try{const t=(0,y.LX)(u,r[0],e.variableValues),a=c(n,t,e.contextValue,p);let d;return d=(0,i.t)(a)?a.then((t=>x(e,l,r,p,o,t))):x(e,l,r,p,o,a),(0,i.t)(d)?d.then(void 0,(t=>k((0,f.y)(t,r,(0,s.N)(o)),l,e))):d}catch(d){return k((0,f.y)(d,r,(0,s.N)(o)),l,e)}}function E(e,t,n,r,o){return{fieldName:t.name,fieldNodes:n,returnType:t.type,parentType:r,path:o,schema:e.schema,fragments:e.fragments,rootValue:e.rootValue,operation:e.operation,variableValues:e.variableValues}}function k(e,t,n){if((0,v.zM)(t))throw e;return n.errors.push(e),null}function x(e,t,n,a,u,p){if(p instanceof Error)throw p;if((0,v.zM)(t)){const r=x(e,t.ofType,n,a,u,p);if(null===r)throw new Error(`Cannot return null for non-nullable field ${a.parentType.name}.${a.fieldName}.`);return r}return null==p?null:(0,v.HG)(t)?function(e,t,n,r,o,a){if(!(0,l.i)(a))throw new c.__(`Expected Iterable, but did not find one for field "${r.parentType.name}.${r.fieldName}".`);const u=t.ofType;let p=!1;const d=Array.from(a,((t,a)=>{const l=(0,s.Q)(o,a,void 0);try{let o;return o=(0,i.t)(t)?t.then((t=>x(e,u,n,r,l,t))):x(e,u,n,r,l,t),(0,i.t)(o)?(p=!0,o.then(void 0,(t=>k((0,f.y)(t,n,(0,s.N)(l)),u,e)))):o}catch(c){return k((0,f.y)(c,n,(0,s.N)(l)),u,e)}}));return p?Promise.all(d):d}(e,t,n,a,u,p):(0,v.UT)(t)?function(e,t){const n=e.serialize(t);if(null==n)throw new Error(`Expected \`${(0,r.X)(e)}.serialize(${(0,r.X)(t)})\` to return non-nullable value, returned: ${(0,r.X)(n)}`);return n}(t,p):(0,v.m0)(t)?function(e,t,n,r,o,a){var u;const s=null!==(u=t.resolveType)&&void 0!==u?u:e.typeResolver,l=e.contextValue,c=s(a,l,r,t);if((0,i.t)(c))return c.then((i=>j(e,R(i,e,t,n,r,a),n,r,o,a)));return j(e,R(c,e,t,n,r,a),n,r,o,a)}(e,t,n,a,u,p):(0,v.lp)(t)?j(e,t,n,a,u,p):void(0,o.k)(!1,"Cannot complete value of unexpected output type: "+(0,r.X)(t))}function R(e,t,n,o,a,i){if(null==e)throw new c.__(`Abstract type "${n.name}" must resolve to an Object type at runtime for field "${a.parentType.name}.${a.fieldName}". Either the "${n.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,o);if((0,v.lp)(e))throw new c.__("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");if("string"!=typeof e)throw new c.__(`Abstract type "${n.name}" must resolve to an Object type at runtime for field "${a.parentType.name}.${a.fieldName}" with value ${(0,r.X)(i)}, received "${(0,r.X)(e)}".`);const u=t.schema.getType(e);if(null==u)throw new c.__(`Abstract type "${n.name}" was resolved to a type "${e}" that does not exist inside the schema.`,o);if(!(0,v.lp)(u))throw new c.__(`Abstract type "${n.name}" was resolved to a non-object type "${e}".`,o);if(!t.schema.isSubType(n,u))throw new c.__(`Runtime Object type "${u.name}" is not a possible type for "${n.name}".`,o);return u}function j(e,t,n,r,o,a){const u=b(e,t,n);if(t.isTypeOf){const s=t.isTypeOf(a,e.contextValue,r);if((0,i.t)(s))return s.then((r=>{if(!r)throw A(t,a,n);return N(e,t,a,o,u)}));if(!s)throw A(t,a,n)}return N(e,t,a,o,u)}function A(e,t,n){return new c.__(`Expected value of type "${e.name}" but got: ${(0,r.X)(t)}.`,n)}const I=function(e,t,n,r){if((0,u.y)(e)&&"string"==typeof e.__typename)return e.__typename;const o=n.schema.getPossibleTypes(r),a=[];for(let u=0;u<o.length;u++){const r=o[u];if(r.isTypeOf){const o=r.isTypeOf(e,t,n);if((0,i.t)(o))a[u]=o;else if(o)return r.name}}return a.length?Promise.all(a).then((e=>{for(let t=0;t<e.length;t++)if(e[t])return o[t].name})):void 0},M=function(e,t,n,r){if((0,u.y)(e)||"function"==typeof e){const o=e[r.fieldName];return"function"==typeof o?e[r.fieldName](t,n,r):o}};function F(e,t,n){const r=n.name.value;return r===m.Az.name&&e.getQueryType()===t?m.Az:r===m.tF.name&&e.getQueryType()===t?m.tF:r===m.hU.name?m.hU:t.getFields()[r]}},82182:function(e,t,n){function r(e){return"function"==typeof(null==e?void 0:e.then)}n.d(t,{t:function(){return r}})}}]);